const width = 800;
const height = 400;
const margin = { top: 20, right: 30, bottom: 50, left: 60 };

// Create SVG
const svg = d3.select("#chart")
    .attr("width", width)
    .attr("height", height);

const tooltip = d3.select(".tooltip");

// Load Data
d3.csv("netflix_titles.csv").then((data) => {
    // Parse and clean data
    const calculateGenreCounts = (filteredData) => {
        const genreCounts = {};
        filteredData.forEach(d => {
            const genres = d.listed_in.split(", ");
            genres.forEach(genre => {
                if (!genreCounts[genre]) genreCounts[genre] = 0;
                genreCounts[genre]++;
            });
        });
        return Object.keys(genreCounts).map(genre => ({
            genre,
            count: genreCounts[genre]
        }));
    };

    let currentType = "all"; // Default filter
    let genreData = calculateGenreCounts(data);

    // Scales
    const x = d3.scaleBand()
        .domain(genreData.map(d => d.genre))
        .range([margin.left, width - margin.right])
        .padding(0.1);

    const y = d3.scaleLinear()
        .domain([0, d3.max(genreData, d => d.count)])
        .nice()
        .range([height - margin.bottom, margin.top]);

    // Axes
    const xAxis = svg.append("g")
        .attr("transform", `translate(0,${height - margin.bottom})`);

    const yAxis = svg.append("g")
        .attr("transform", `translate(${margin.left},0)`);

    const updateAxes = () => {
        xAxis.call(d3.axisBottom(x).tickSizeOuter(0))
            .selectAll("text")
            .attr("transform", "rotate(-45)")
            .style("text-anchor", "end");

        yAxis.call(d3.axisLeft(y));
    };

    updateAxes();

    // Bars
    const barsGroup = svg.append("g");

    const updateChart = () => {
        // Filter data based on type
        let filteredData = data;
        if (currentType !== "all") {
            filteredData = data.filter(d => d.type === currentType);
        }
        genreData = calculateGenreCounts(filteredData);

        // Update scales
        x.domain(genreData.map(d => d.genre));
        y.domain([0, d3.max(genreData, d => d.count)]).nice();

        // Update Axes
        updateAxes();

        // Bind data
        const bars = barsGroup.selectAll(".bar")
            .data(genreData, d => d.genre); // Key function to track elements

        // Enter phase (new elements)
        bars.enter()
            .append("rect")
            .attr("class", "bar")
            .attr("x", d => x(d.genre))
            .attr("y", height - margin.bottom) // Start at bottom
            .attr("width", x.bandwidth())
            .attr("height", 0) // Start at 0 height
            .on("mouseover", (event, d) => {
                tooltip.style("display", "block")
                    .style("left", `${event.pageX + 5}px`)
                    .style("top", `${event.pageY - 30}px`)
                    .html(`<strong>${d.genre}</strong><br>Count: ${d.count}`);
            })
            .on("mouseout", () => tooltip.style("display", "none"))
            .transition()
            .duration(750)
            .attr("y", d => y(d.count))
            .attr("height", d => y(0) - y(d.count));

        // Update phase (existing elements)
        bars.transition()
            .duration(750)
            .attr("x", d => x(d.genre))
            .attr("y", d => y(d.count))
            .attr("width", x.bandwidth())
            .attr("height", d => y(0) - y(d.count));

        // Exit phase (elements to be removed)
        bars.exit()
            .transition()
            .duration(750)
            .attr("y", height - margin.bottom)
            .attr("height", 0)
            .remove();
    };

    // Dropdown filter
    d3.select("#typeFilter").on("change", function () {
        currentType = this.value;
        updateChart();
    });

    // Initial chart
    updateChart();
});